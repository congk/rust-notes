
# 数据类型

Rust 是静态类型语言，编译过程中编译器需要知道所有变量的具体类型。大部分情况下，编译器可通过类型推导得出变量类型，但当编译器无法自动推导出变量类型时，为了避免混淆，需要开发者手动添加类型标注。

```rs
// parse 用于解析字符串为数值，其可以处理多种数据类型
// 当前编译器无法自行推导出具体需要的变量类型，为避免混淆，则需要手动标注类型
let guess: u32 = '42'.parse().expect("Not a number!");
``` 

# 标量类型（值类型）

#### 整型

| 长度 | 有符合 | 无符号 |
|:--- |:-----:|:-----:|
| 8-bits | `i8`| `u8` |
| 16-bits | `i16` | `u16` |
| 32-bits | `i32` | `u32` |
| 64-bits | `i64` | `u64` |
| arch | `isize` | `usize` |

* `isize` 与 `usize` 是两种特殊的整数类型，长度取决于程序运行的目标平台。在 64 位架构上其长度为 `64-bits`，32 位架构上其长度为 `32-bits`
* Rust 对默认整数字面量的推导类型为 `i32`

**关于整型溢出**

* Debug 模式下，整型溢出会触发 **panic** 异常退出
* Release 模式（编译构建使用了`--release`标记）下，整型溢出会发生**二进制补码环绕**（如 u8 数据 256 = 0）

**整数字面量**

> 除 **Byte** 字面量外，其他所有字面量允许使用 `_` 对数据进行任意分割以便于阅读，同时可以在数字后追加标注类型

| 整数字面量 | 示例值 | 示例                                |
|:--------|:----:|:--------------------------------|
| Decimal | 1000 | `1000`、`1_000`、`10_00`、`1000u32`、`100_0u32`、`1_0_0_0_u32` |
| Hex     | 255  | `0xff`、`0x_f_f`、`0xffu32`、`0x_____f__f_______u32` |
| Octal   | 63   | `0o77`、`0o__7_7`、`0o77u32` |
| Binary  | 240  | `0b11110000`、`0b1111_0000`、`0b1111_0000u32` |
| Byte(u8 only) | 65 | `b'A'`                               |

#### 浮点型

Rust 对于浮点字面量的默认推导类型为 `f64`

| 类型 | 长度 | 描述 |
|:---:|:-----:|:---|
| `f32` | 32-bits | 单精度浮点数 |
| `f64` | 64-bits | 双精度浮点数 |

#### 布尔值 `bool`

`true` 与 `false`，长度 `8-bits`

```rs
let ok = true;
let ok: bool = true;
```

#### 字符型 `char`

`char` 类型使用**单引号**指定，长度 `32-bits`，是一个 Unicode 标量值，可以表示比 ASCII 更多的字符内容。

```rs
let c = 'z';
let c: char = 'z';
```

# 复合类型

> Rust 提供了两种内置的基础复合类型：元组（tuple）和数组（array）

#### 元组

元组拥有一个固定长度，无法在声明后增加或减少其拥有的元素数量。元组每个元素都可以拥有不同的类型。

```rs
// 声明元组类型变量 tup
let tup: (i32, f64, u8) = (500, 6.4, 1);

// 元组数据解构，并对变量 x, y, z 分别赋值
let (x, y, z) = tup;

// 通过 . 运算符获取元组中的元素值，索引从 0 开始
let first = tup.0;
```

#### 数组

* Rust 中数组为**类型化数组**，每个元素必须拥有相同的数据类型
* 与其他语言不通，Rust 中数组拥有一个固定的长度，声明后不能随意更改大小
* Rust 标准库中提供了动态数组`Vector`，一个类似于数组的集合结构，但允许用户自由调整数组长度

```rs
// 声明数组，Rust 自动推导类型为 [i32; 5]
let arr = [1, 2, 3, 4, 5];

// 显式声明数组类型: [type; len]
let arr: [i8; 5] = [1, 2, 3, 4, 5];

// 声明一个长度为 5 的数组，并以值 1 进行填充，类型推导为 [i32; 5]
let arr = [1; 5];
```

* 数组由**一整块分配在栈上的内存**组成，通过索引来访问其中的元素。
* 尝试访问数组元素时，如果索引超出数组长度，Rust 将出现编译异常。*老版本的 Rust 会在运行时抛出 panic 异常终止运行，以此规避其他语言中使用错误的内存地址数据引发的不确定性问题。*

```rs
let arr = [1; 5];
let ele = arr[10];      // 编译异常: index out of bounds: the length is 5 but the index is 10
```
