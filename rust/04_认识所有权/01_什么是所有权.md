# 什么事所有权

Rust 不存在垃圾回收机制（Garbage Collector）做定时内存检测回收（如 Java、Javascript），也不需要开发者手动释放内存（如 C、C++）；

Rust 通过**包含特定规则的所有权系统（或称所有权机制）**管理内存，这套规则允许编译器**在编译程序的过程中执行检查**工作，而不会产生任何的**运行时开销**。

> 建议先行阅读：[堆与栈](rust/04_认识所有权/堆与栈.md)

## !!所有权规则

* Rust 的每一个值都有一个变量作为它的**所有者**。
* 同一时刻，值有且仅有一个所有者。
* 当**所有者**离开自己的作用域时，它持有的值就会被释放掉。

> 个人章节解读：
> 1. 核心逻辑：**所有权主要针对的是堆内存的分配和回收，栈内存无需考虑**
> 2. Rust 中每个**变量**都有一个独立的栈内存空间，用于存储数据地址；
> 3. Rust 中值类型（即标量类型）数据完全存储在栈中，因此**所有值类型数据可以忽视所有权规则限制**。
> 4. 对于 Rust 中复合类型数据，存在不同的内存布局；它们**通过栈内存存储结构数据**，而其内容数据分两种情况：
>> * 4.1. 当内容数据为**定长数据**时，通过栈内存存储
>> * 4.2. 当内容数据为**非定长数据**时，通过堆内存存储，堆内存所有权仅由某一个变量持有。
> 5. 在通过完全使用栈内存的数据（包括完全栈存储的复合型数据）对其他变量进行赋值时，其**赋值过程等同于数据深拷贝**，可以忽视所有权规则限制。
> 6. 通过使用堆内存的数据对其他变量进行赋值，堆内存的所有权会同时转移至新变量，进而导致原变量所有权丢失，继续使用原变量会触发编译异常。
> 7. 变量离开自己的**作用域**时，Rust 会弹出其占据的独立的栈内存；若变量同时拥有某堆内存的所有权，Rust 会自动调用 **Drop trait** 的 `drop()` 的方法以释放堆内存。

## String 类型

* 字符串字面量（如：`"hello"`）是**不可变**的，编译时这种硬编码的文本被嵌入到最终的可执行文件中，所以访问字符串字面量非常高效。
* 字符串类型 String 需要在**堆**上分配一定的内存空间，以存储编译时无法确定大小的文本。

#### 内存布局

* 布局左侧为栈内存数据，存储 String 字符串的结构数据，包括字符串内容指针（ptr）、长度（len）、容量（capacity）。
* 布局右侧为堆内存数据，存储字符串内容 `"hello"`

![String 类型内存布局](https://doc.rust-lang.org/book/img/trpl04-01.svg)

## 内存与分配

对于 String 类型而言，为了支持一个可变的文本类型，需要**运行时**向操作系统在堆中申请一块在内存以存放数据，并在使用结束使用后将内存归还给操作系统。

* 内存申请：String 类型使用的内存是由操作系统在运行时动态分配出来的，如调用 `String::from("hello, world")` 时。
* 内存回收：Rust 在变量离开作用域时（即 `}` 处），会自动调用一个叫 `drop()` 的特殊函数以释放内存；其他语言则通过 GC 垃圾回收机制或手动释放。

```rs
{
    let s1 = String::from("hello");  // 从这里开始，s 变量有效，并申请堆内存以存放数据
}                                   // s 变量离开作用域，变量 s 失效
```

#### 变量与数据交互的方式：移动

> 同一时刻仅有一个变量持有**堆内存**的所有权，其意义在于有效避免了内存的二次释放问题。

```rs
fn main() {
    let s1 = String::from("hello, world");

    // 将 s1 变量赋值给 s2
    // s2 <拷贝> 栈内存取得字符串结构数据，与 s1 变量持有的栈内存共同入栈
    // 同时堆内存所有权移动给变量 s2，变量 s1 丧失所有权，变量 s1 失效
    let s2 = s1;

    // 访问丧失内存所有权的变量会引发编译异常
    println!("The value of x is {}", s1); // 编译异常：borrow of moved value: `s1

    // 当 s1 离开作用域时，Rust 仅回收其栈内存
    // 当 s2 离开作用域时，Rust 回收其栈内存，并释放堆内存
}
```

![](https://doc.rust-lang.org/book/img/trpl04-04.svg)

#### 变量与数据交互的方式：克隆

调用 `clone()` 方法，会将 String 类型数据的堆内存数据进行**深拷贝**，并返回新的堆内存地址。

```rs
let s1 = String::from("hello");
let s2 = s1.clone();    // s1 的堆内存数据深拷贝至 s2，因此 s1 变量仍有效

println!("s1 = {}, s2 = {}", s1, s2);
```

![](https://doc.rust-lang.org/book/img/trpl04-03.svg)

#### 栈上数据的复制

```rs
fn main() {
    // x 为整型，完全使用栈内存存储
    let x = 1;
    // 将 x 赋值给 y，相当于数据深拷贝，y 拥有独立栈内存，将 x 的数据拷贝至其中
    let y = x;

    // 再次访问 x 不会引发异常
    println!("The value of x is {}", x);
    println!("The value of y is {}", y);

    // 元组数据为复合类型，但当前示例中，其元素均为值类型数据，因此其并未使用到堆内存
    let tup = (1, 3, 5);
    let tup2 = tup;

    // 再次访问 tup 也不会引发异常
    println!("The value of tup.1 is {}", tup.1);

    // 离开作用域时，Rust 回收所有变量的栈内存空间
}
```

#### Copy trait

Rust 提供了一个名为 `Copy` 的 trait（特质），所有拥有或实现了该特质的类型，它的变量在赋值给其他变量时，不会发生所有权转移，从而保持原变量可用性。

对于实现了 `Drop` trait 的类型，Rust 不允许其再实现 `Copy` trait。

> 内置实现了 `Copy` trait 的类型有：
> * 所有的整数类型
> * 布尔类型
> * 字符类型 `char`
> * 所有的浮点类型
> * 所有的元组类型及数组类型，若类型中的所有元素都实现了 Copy trait，那么这个元组或数组也实现了 Copy trait。

## 所有权与函数

将值传递给函数，在语义上类似于对变量进行赋值，会引发**数据拷贝**或**所有权转移**；函数在返回值的过程中也会发生所有权的转移。

当一个持有堆数据的变量离开作用域时，它的数据就会被 drop 清理回收，**除非这些数据的所有权转移到了另一个变量上**。

```rs
fn main() {
    // String 类型，使用堆内存，赋值会发生所有权转移
    let str = String::from("hello, world");

    // 将值传递给函数，所有权转移到函数内部
    takes_ownership(str);

    // 继续尝试使用 str 会触发编译异常
    // println!("{}", str);   // 编译异常：borrow of moved value: `str`

    // 取得返回值内存所有权
    let str2 = given_ownership();

    println!("{}", str2);

    // 离开作用域时，仅回收 str 占用的栈内存，str 不再用于堆内存所有权
    // 回收 str2 的栈内存与堆内存
}

fn takes_ownership(some_string: String) {
    // 取得内存所有权
    println!("{}", some_string);

    // 离开作用域时，Rust 会回收 some_string 的栈内存与堆内存
}

fn given_ownership() -> String {
    // 声明 String 类型变量
    let some_string = String::from("hello");

    // 等同于 return some_string; 返回值会将所有权转移给调用方
    some_string

    // 离开作用域时，仅回收 some_string 的栈内存
}
```
