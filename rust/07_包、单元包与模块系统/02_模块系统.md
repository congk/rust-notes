# 模块系统

> 书中对于多文件模块的说明过于简单，这里做一些补充和总结。

在前端模块化实践中，`ESM` 等前端模块的定义以文件为单位，所有模块之间可以通过文件路径直接引用和访问模块内定义的公开元素。

对于前端开发者而言，Rust 的模块系统系统更为复杂和严格：

* 每个 `.rs` 文件都被视为一个**与文件同名的模块**，模块内部可以定义任何元素（包括子模块），每个元素都是模块的树状子节点。
* 每个目录下允许存在一个 `mod.rs` 文件，该文件被视为一个**在父级目录下的与父级目录同名的模块**，从而将目录内的元素向父级目录暴露。这意味着**目录下 `mod.rs` 之外的 rs 文件必须通过 `mod.rs` 导出，才能被 rustc 编译器发现和检查**。
* Cargo 工程约定 `src/` 目录下的 `main.rs`、`lib.rs` 和 `bin/*.rs` 为单元包入口文件，因此 rustc 将它们视为一个**模块树**的根节点模块，**可以通过 `crate::` 代指来对模块树进行绝路路径匹配**。
* 模块树内部可以通过 `super::` 代指当前模块的父模块（不是父节点），从而进行相对路径匹配，但 `super::` 只能向上一级匹配，`super::super::` 是非法的。

> **注意：父模块不等于模块树的父节点。**

**补充说明:**

* `mod.rs` 的作用类似于前端规范中的 `index.js` 文件，但在 Rust 中是强制性的要求；
* `mod.rs` 文件在 `src/` 和 `src/bin/` 目录下无效：
  * 在 `src/` 目录下，`main.rs` 与 `lib.rs` 为根节点模块，文件本身可以取代 `mod.rs` 的作用。
  * 在 `src/bin/` 目录下，每个 `.rs` 文件都视为一个独立的单元包，包括 `bin/mod.rs`。

## 私有性与可见性

* Rust 中所有条目（结构体、枚举、函数、模块、方法、常量）**默认都是私有的**，通过 `pub` 关键字**对模块外部**开放访问。
* **模块内部**所有条目相互之间都是开放可见的。
* 父模块无法访问子模块内的私有条目，**子模块可以获取到父模块的所有条目（包括私有）**。

#### Struct & Enum

* 对结构体声明为 pub，并不影响其内部字段和方法的私有性
* 对枚举声明为 pub，那么其所有变体均为 pub

```rs
// 通过 mod 关键字定义模块
mod foo {
    // 对结构体声明为 pub，并不影响其内部字段和方法的私有性
    pub struct User {
        pub name: String,
        age: u8,
    }

    // 将枚举类型定义为 pub，那么其所有变体均为 pub
    pub enum IpAddr {
        V4,
        V6,
    }
}
```

## 多个单元包的代码复用

由于 `lib.rs` 与 `main.rs` 都是模块树的根节点，且处于同一目录下，因此 `lib.rs` 与 `main.rs` 之间可以共享模块树中的元素。同理，`bin/` 目录下的所有 rs 文件也可以共享代码。

但是，`lib.rs`、`main.rs` 不能使用 `bin/` 目录下的 rs 文件，而 `bin/` 目录下的 rs 文件仅能以引用外部包的方式访问 `lib.rs` 对外暴露的内容。

参考：[bin 目录中如何引用上层模块？](https://rustcc.cn/article?id=dcc947c4-21a9-4ba0-ba59-43f6b580aae6)
