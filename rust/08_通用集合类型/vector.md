# 动态数组 `Vec<T>`

> 非定长、类型化数组

```rs
// 需要显式声明元素类型，因为当前没有任何元素，Rust 无法通过推导获取类型
let vec: Vec<u8> = Vec::new();

// 类型为 Vec<i32>，i32 是数字的默认类型，vec! 是宏，便于快速定义 Vec<T> 实例
let vec2 = vec![1, 2, 3];
```

Rust 中所有变量默认都是不可变的，对动态数组也一样。如果需要对动态数组进行修改，需要 `mut` 声明.

```rs
fn main() {
    let mut vec = vec![1, 2, 3];
    vec.push(4);

    // 和 struct 结构体实例一样，动态数组内的所有元素会随着动态数组销毁而销毁
}
```

**注意**

**不允许在存在不可变引用的情况下，修改动态数组内容**，原因在于动态数组的元素是连续存储在堆中，插入新的元素可能导致没有足够的内存空间存储，进而需要重新分配内存，并将旧的元素移动到新的空间内，释放原空间内存。这会导致已存在的引用指向了被释放的内存空间，造成悬垂引用，进而引发异常。

> 参考 Rust 中对于引用、可变引用的使用限制：
> * 允许同时声明多个不可变引用。
> * 不能在拥有不可变引用的同时去声明可变引用。

## 读取动态数组元素

```rs
let v = vec![1, 2, 3, 4, 5];

// 通过索引获取，当索引超出动态数组长度时，应用程序会派发 panic 并终止运行
let third = &v[2];

// 通过 get 方法获取元素，返回值为 Option<T> 枚举，当索引超出动态数组长度时，返回 Option::None 变体，不会使程序崩溃
let thrid = v.get(2)
```

## 遍历

```rs
let v = vec![100, 200, 300];

for i in &v {
  println!("{}", i);
}

// 为遍历修改，需要声明变量为可变变量
let mut v = vec![100, 200, 300];

for i in &mut v {
  // i 是一个引用，使用 * 解引用运算符获取 i 绑定的值
  *i += 50;
}
```

## 通过枚举使用动态数组存储多个类型的值

```rs
// 枚举所有变体均会视为枚举类型，因此可以被用于类型化数组
enum Item {
  Int(i32),
  Float(f64),
  Text(String)
}

// 其类型为 Vec<Item>
let v = vec![
  Item::Int(3),
  Item::Float(3.14),
  Item::String(String::from("hello")),
];
```
