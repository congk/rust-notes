# 引用的生命周期

Rust 中每个引用都有一个自己的生命周期（lifetime），它对应着引用保持有效性的作用域。大多数时候生命周期是隐式且可以被推导的，当引用的声明周期可能以不同的方式相互关联时，就必须手动标注生命周期。Rust 需要我们注明泛型声明周期参数之间的关系，来确保运行时实际使用的引用一定是有效的。

生命周期最主要的目标在于**避免悬垂引用**，进而避免程序引用到非预期的数据。

```rs
fn main() {
    let r;
    {
        let x = 5;
        // 给 r 赋值引用
        r = &x;           // 编译异常：`x` does not live long enough
    }

    // r 的生命周期长于 x，但却指向了生命周期较短的 x 的内存，因此编译无法通过

    // 打印引用
    println!("r: {}", r);
}
```

Rust 编译器拥有一个**借用检查器（borrow checker）**，它被用于比较不同的作用域并确定所有借用的合法性。

#### 函数中的泛型生命周期

```rs
fn longest(x: &str, y: &str) -> &str {
  if x.len() > y.len() {
    x
  } else {
    y
  }
}
```

上面代码示例无法正常通过编译，原因在于**借用检查器无法确定 x、y 入参的具体生命周期，也无法得知与返回的生命周期之间的关联关系，进而无法确保引用有效性**。

为了解决此问题，需要给函数添加一个泛型生命周期参数，来定义（或称约束）引用之间的关系，进而使借用检查器能够进行正常的分析。

#### 生命周期标注法

**生命周期标注并不会改变任何引用的生命周期长度，在不影响生命周期的前提下，标注本身会被用于描述多个引用生命周期之间的关系。**

```rs
&i32                // 引用
&'a i32             // 拥有显式生命周期的引用
&'a mut i32         // 拥有显式生命周期的可变引用
```

单个生命周期的标注本身并没有太多意义，标注之所以存在是为了向 Rust 描述多个泛型生命周期参数之间的关系。

```rs
// x 拥有生命周期 'a，y 也拥有生命周期 'a，这意味着 x 与 y 的生命周期一样长
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    // ...
}
```

当将具体的引用传入函数时，`'a` 会被 x 与 y 的**生命周期重叠**的部分所替代，**泛型生命周期 `'a` 会被具体化为 x、y 中生命周期较短的一个**。

因为函数返回值的生命周期也被标记为 `'a`，所以返回的引用在具体化后的生命周期内都是有效的。

```rs
fn main() {
    let str1 = String::from("long string is long");

    let result;

    {
        // str1 生命周期长期 str2，两个引用的生命周期的重叠部分为 str2 的生命周期
        let str2 = String::from("xyz");

        // 调用上例中的 longest 函数，入参后以 str2 的生命周期替换 'a，返回值 result 的生命周期应该短于 str2
        result = longest(str1.as_str(), str2.as_str());

        // str2 的生命周期结束
    }

    // 访问 result 导致编译异常，因为 result 的生命周期不应长于 str2
    println!("Result: ${}", result);
}
```

**当返回值返回一个引用时，返回类型的生命周期参数必须与其中一个参数的生命周期参数相匹配。**当返回的引用没有指向任何参数时，那么它只能是指向一个创建于函数内部的值，由于这个值会因为函数的结束而离开作用域，所以返回的内容会变成**悬垂引用**。Rust 不允许出现悬垂引用，因此编译无法通过。

#### 结构体中定义的生命周期标注

结构体包含引用时，需要为每一个引用标注生命周期。

```rs
// 标注 'a 表示类实例的生命周期应该不长于 part 引用的生命周期，否则会造成 part 悬垂引用
struct ImportantExcerpt<'a> {
    part: &'a str,
}
```

#### 生命周期省略

Rust 编译器对一些特定的模式建立了**生命周期省略规则**，对符合场景模式的代码不再强制要求开发者显式标注，而由借用检查器会自行推导得出。未来随着 Rust 的发展与迭代，需要开发者显式标注的场景可能会越来越少。

函数或方法的参数的生命周期被称为**输入生命周期（input lifetimes）**，而返回值的生命周期被称为**输出生命周期（output lifetimes）**。

编译器会采用三条规则来判断引用何时不需要明确的标注，第一条规则适用于输入生命周期，后两条规则适用于输出生命周期。如果编译器检查完这三条规则后**仍然存在没有计算出生命周期的引用**，编译器将会停止并生成错误。这些规则适用于 fn 定义，以及 impl 块。

以下面四个函数举例对 Rust 借用检查器的推导方式进行说明

```rs
fn func1(s: &str) -> &str;
fn func2(&self, s: &str) -> &str;
fn func3(s: &str, s2: &str) -> &str;
fn func4(s: &str) -> i32;
```

**应用规则 1：每一个引用型参数都有它自己的生命周期参数**

```rs
// 按照规则 1，编译器会对函数进行标注

fn func1<'a>(s: &'a str) -> &str;
fn func2<'a, 'b>(&'a self, s: &'b str) -> &str;
fn func3<'a, 'b>(s: &'a str, s2: &'b str) -> &str;
fn func4<'a>(s: &'a str) -> i32;

// func4 所有引用均已推导出生命周期，因此 func4 函数无需继续检查，也无需开发者手动标注
```

**应用规则 2：如果只有一个输入生命周期参数，那么它被赋予所有输出生命周期参数。**

```rs
// func1 只有一个输入声明周期，符合规则，所以输出生命周期也被标注为 'a
// func2 与 func3 不符合规则，不做处理

fn func1<'a>(s: &'a str) -> &'a str;
fn func2<'a, 'b>(&'a self, s: &'b str) -> &str;
fn func3<'a, 'b>(s: &'a str, s2: &'b str) -> &str;

// func1 所有引用均已推导出生命周期，因此 func1 无需继续检查，无需开发者手动标注
```

**应用规则 3：如果方法有多个输入生命周期参数并且其中一个参数是 `&self` 或 `&mut self`，那么所有输出生命周期参数被赋予 self 的生命周期。**

```rs
// func2 符合规则，因此返回值标注生命周期 'a，func2 生命周期推导完毕
fn func2<'a, 'b>(&'a self, s: &'b str) -> &'a str;

fn func3<'a, 'b>(s: &'a str, s2: &'b str) -> &str;
```

经过三条规则检查，Rust 编译器无法完成对 `func3` 中引用生命周期的推导，因此会停止编译；这意味着需要开发者手动对其进行生命周期标注。

#### 为带有生命周期的结构体实现方法

impl 块里的方法签名中，引用可能与结构体字段中的引用相关联，也可能是独立的。另外，生命周期省略规则也经常让我们无需在方法签名中使用生命周期标注（参考规则 3）。

```rs
impl<'a> ImportantExcerpt<'a> {
    // 无需标注
    fn func2(&self, s: &str) -> &str {}

    // func3 不满足忽略规则，需要标注生命周期，但可以与结构体字段生命周期 'a 无关
    fn func3<'b>(s: &'b str, s2: &'b str) -> &'b str {}
}
```

#### 静态生命周期

`'static` 是一个特殊的生命周期，它标注引用存活于整个程序运行过程中；需要注意，**生命周期标注并不会改变任何引用的生命周期长度**，标注仅是用于帮助 Rust 编译器分析引用的生命周期；

所有的字符串字面量都拥有 `'static` 生命周期，文本被直接储存在程序的二进制文件中而这个文件总是可用的，但不代表引用全局有效，原因在于变量会被可用作用域限制。

```rs
fn main() {
    let s;
    {
        s = "abc";

        // 显式标注字符串字面量 'static
        let s2: &'static str = "def";
    }

    // s 是个 &str 引用，"abc" 是字符串字面量，其生命周期默认为 'static，引用指向的内存数据总是可用
    println!("s: {}", s);           // output: abc

    // s2 不在作用域内，访问会产生异常
    println!("s2: {}", s2);         // 编译异常：cannot find value `s2` in this scope
}
```

#### 泛型、trait、生命周期同时使用

> 生命周期标注本身也是泛型的一种

```rs
fn some_func<'a, T>(x: &'a str, y: &'a str, ann: T) -> &'a str
where
    T: Display,
{
    // ...
}
```