# `RefCell<T>` 与内部可变性模式

内部可变性（interior mutability）是 Rust 的设计模式之一，它允许你在只持有不可变引用的前提下对数据进行修改；通常而言，类似的行为会被借用规则所禁止。

为了能够改变数据结构，内部可变性模式在它的数据结构中使用了 **unsafe** 代码来绕过 Rust 正常的可变性和借用规则。

#### 使用 `RefCell<T>` 在运行时检查借用规则

与 `Rc<T>` 不同，`RefCell<T>` 类型代表了其持有数据的唯一所有权。

`RefCell<T>` 与 `Box<T>` 不同，**对于 `RefCell<T>` 的代码，Rust 只会在运行时检查所有权规则**，并在出现违反借用规则的情况下触发 panic 提前中止程序。

与 `Rc<T>` 类似，`RefCell<T>` 只能被用于单线程场景中，强行将其用于多线程环境中会产生编译错误。

#### 如何选择使用 `Box<T>`、`Rc<T>` 或 `RefCell<T>`

* `Rc<T>` 允许一份数据拥有多个所有者，而 `Box<T>` 与 `RefCell<T>` 都只有一个所有者。
* `Box<T>` 允许在编译时检查可变借用或不可变借用；`Rc<T>` 仅允许在编译时检查不可变借用；而 `RefCell<T>` 在运行时检查可变或不可变借用。
* 由于 `RefCell<T>` 允许我们在运行时检查可变借用，所以即便 `RerCell<T>` 本身是不可变的，我们仍然能够更改其中存储的值。

#### 内部可变性：可变地借用一个不可变的值

在某些特定情况下，我们需要在一个值对外保持不可变性的同时能够在方法内部修改自身。除了这个值本身的方法，其余的代都不能修改。使用 `RefCell<T>` 是获取这种内部可变性的的一种方法。不过它并没有完全绕开借用规则，而仅仅是将检查延后到了运行时。

```rs
// RefCell 未被预导入到作用域内，需要手动导入
use std::cell::RefCell;

fn main() {
    let x = RefCell::new(5);

    // borrow_mut 方法返回 RefMut<i32> 型智能指针
    let mut x1 = x.borrow_mut();
    // RefCell 是智能指针的一种，实现了 Deref trait，因此可以通过 * 解引用，并重新赋值
    *x1 = 6;
    println!("x = {}", x1);                   // output: x = 6

    // 因为借用规则，可变引用与不可变引用不能共存，所以为了使用 x.borrow() 声明不可变引用，这里提前释放可变引用
    drop(x1);
    // borrow() 返回 Ref<T> 型智能指针
    println!("x = {}", x.borrow());           // output: x = 6
}
```