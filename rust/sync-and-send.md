# `Sync trait` 与 `Send trait`

Rust 提供了 `std::marker` 模块的 `Sync trait` 与 `Send trait` 以便于我们对线程并发自行拓展。

#### 允许在多个线程间转移所有权的 `Send trait`

只有实现了 `Send trait` 的类型才能可以安全地在线程间转移所有权。除了  `Rc<T>` 等少数类型，Rust 几乎所有类型都实现了 `Send trait`；如果将克隆后的 `Rc<T>` 值的所有权转移至另一个线程，那么两个线程可能同时更新引用计数导致计数错误。`Rc<T>` 只被设计在单线程场景中使用，它也无须为线程安全付出额外的性能开销。

任何完全由 Send 类型组成的复合类型都会自动标记为 Send。

#### 允许多线程同时访问的 `Sync trait`

只有实现了 `Sync trati` 的类型才可以安全地被多个线程引用。对于任何类型 T，如果 &T 满足约束 Send，那么 T 就是满足 Sync 的。这意味着 T 的引用能够被安全地传递至另外的线程中。与 Send 类似，所有原生类型都满足 Sync 约束，而完全由满足 Sync 的类型组成的复合类型也会被自动标记为满足 Sync 的类型。

智能指针 `Rc<T>` 同样不满足 Sync 约束，其原因与它不满足 Send 约束类似。`RefCell<T>` 与 `Cell<T>` 系统类似也不满足 Sync 约束。`RefCell<T>` 实现的运行时借用检查并没有提供有关线程安全的保证。智能指针 `Mutex<T>` 是 Sync 的，可以被多个线程共享访问。

#### 手动实现 Send 和 Sync 是不安全的

当某个类型完全由实现了 Send 和 Sync 的类型组成时，它就会自动实现 Send 与 Sync。因此并不需要手动地为此种类型实现相关 trait，Send 与 Sync 甚至没有任何可供实现的方法，它们仅仅被用来强化与并发相关的不可变性。

手动实现这些 trait 涉及特殊的不安全代码。当你构建的自定义并发类型包含了没有实现 Send 和 Sync 的类型时，你必须要非常谨慎地确保设计能够满足线程间的安全性要求。